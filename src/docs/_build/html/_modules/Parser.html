

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Parser &mdash; Renpy Interpreter 2025 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=cb975c41"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Renpy Interpreter
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Renpy Interpreter</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">Parser</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for Parser</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">Tokens</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">Error</span><span class="w"> </span><span class="kn">import</span> <span class="n">DetailedError</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">defs</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">AST</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines all classes and logic related to parsing Ren&#39;Py-like script files.</span>

<span class="sd">Parsing is the process of analyzing the script&#39;s syntax to ensure it follows</span>
<span class="sd">the language rules and converting it into an Abstract Syntax Tree (AST).</span>
<span class="sd">The AST is a structured representation of the script that can be later</span>
<span class="sd">interpreted or compiled by the engine.</span>

<span class="sd">In this project, the parser handles:</span>
<span class="sd">- Token validation and syntax enforcement</span>
<span class="sd">- Construction of AST nodes (LabelNode, SceneNode, ShowNode, etc.)</span>
<span class="sd">- Support for Ren&#39;Py directives such as &#39;scene&#39;, &#39;show&#39;, &#39;hide&#39;, &#39;play&#39;, &#39;with&#39;, etc... (See AST.py for all the ASTnode that are handled)</span>

<span class="sd">Each node in the AST corresponds to a syntactic element of the Ren&#39;Py language.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Parsing class hierarchy for Ren&#39;Py files.</span>

<span class="sd">- TOOL: methods in RPParser_Test (general utilities)</span>
<span class="sd">- BASIC_PARSER: methods in SimpleParser (parsing without dispatch)</span>
<span class="sd">- DISPATCH_PARSER: methods in DispatchParser subclasses (parsing via dispatch table)</span>
<span class="sd">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="RPParser">
<a class="viewcode-back" href="../Parser.html#Parser.RPParser">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RPParser</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class providing TOOL methods for all parser classes.</span>

<span class="sd">    TOOL methods are general utilities used by every parser</span>
<span class="sd">    methods defined in class that inherits this one.</span>
<span class="sd">    &quot;&quot;&quot;</span>
     
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_tokens</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># To browse through all the tokens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_tokens</span> <span class="o">=</span> <span class="n">list_tokens</span> <span class="c1"># Contains the list of tokens (obtained from Tokens module)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="o">=</span> <span class="n">FILE_EOF</span> <span class="c1"># Used to indicate when the renpy file is ending.</span>

<div class="viewcode-block" id="RPParser.eat_skip_until">
<a class="viewcode-back" href="../Parser.html#Parser.RPParser.eat_skip_until">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">eat_skip_until</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_type</span><span class="p">,</span> <span class="n">return_type_found</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span> <span class="c1"># TOOL</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Advance through tokens until `expected_type` is found.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        expected_type : str</span>
<span class="sd">            The type of token to look for.</span>
<span class="sd">        return_type_found [optional] : bool</span>
<span class="sd">            If True, return the token type found.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool or str</span>
<span class="sd">            If return_type_found is False: True if `expected_type` found, False otherwise.</span>
<span class="sd">            If return_type_found is True: token type found, whether it matches `expected_type` or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_tokens</span><span class="p">):</span>
            <span class="n">type_found</span> <span class="o">=</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_tokens</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">type_found</span> <span class="o">!=</span> <span class="n">expected_type</span><span class="p">:</span> <span class="c1"># We didn&#39;t find the expected token</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">return_type_found</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">type_found</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">return_type_found</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">type_found</span>
                <span class="k">return</span> <span class="kc">True</span> <span class="c1"># We found the expected token</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="c1"># End of token list</span></div>

        
<div class="viewcode-block" id="RPParser.eat">
<a class="viewcode-back" href="../Parser.html#Parser.RPParser.eat">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">eat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_type</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">expected_value</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span> <span class="c1"># TOOL</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Consume the next token, optionally verifying its type and value.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        expected_type : str, optional</span>
<span class="sd">            Type of the expected token. If empty string (&quot;&quot;), type check is skipped.</span>
<span class="sd">        expected_value : str, optional</span>
<span class="sd">            Expected value of the token. If empty string (&quot;&quot;), value check is skipped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            The consumed token.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        DetailedError</span>
<span class="sd">            If the token type or value does not match expectations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_tokens</span><span class="p">):</span>
            <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_tokens</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">token_type</span><span class="p">,</span> <span class="n">token_value</span> <span class="o">=</span> <span class="n">__BREAK__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
            <span class="c1"># if expected_type == &quot;&quot;: # We use this special case to skip until we find expected_type in parse_image. </span>
            <span class="c1">#    self.idx += 1</span>
            <span class="c1">#    return __GET__TYPE__TOKEN__(token)</span>
            <span class="k">if</span> <span class="n">token_type</span> <span class="o">!=</span> <span class="n">expected_type</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Wrong token type. Expected </span><span class="si">{</span><span class="n">expected_type</span><span class="si">}</span><span class="s2"> and got </span><span class="si">{</span><span class="n">token_type</span><span class="si">}</span><span class="s2"> instead&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">expected_value</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">token_value</span> <span class="o">!=</span> <span class="n">expected_value</span><span class="p">:</span> <span class="c1"># expected_token_value!= &quot;&quot; is for user defined variable: We don&#39;t want to raise an error.</span>
                <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Wrong value used for the token: </span><span class="si">{</span><span class="n">token_type</span><span class="si">}</span><span class="s2">. Expected value was </span><span class="si">{</span><span class="n">expected_value</span><span class="si">}</span><span class="s2"> instead of </span><span class="si">{</span><span class="n">token_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">token</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="c1"># End of token list</span></div>

  
<div class="viewcode-block" id="RPParser.token_peek">
<a class="viewcode-back" href="../Parser.html#Parser.RPParser.token_peek">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">token_peek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> <span class="c1"># TOOL</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Look at the next token without advancing the index.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        return_type : bool, optional</span>
<span class="sd">            If True (default), return the token type.</span>
<span class="sd">            If False, return the full token.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            Token type if return_type is True, else the full token string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_tokens</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">return_type</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_tokens</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">])</span> 
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_tokens</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="c1"># End of token list</span></div>

    
<div class="viewcode-block" id="RPParser.vomit">
<a class="viewcode-back" href="../Parser.html#Parser.RPParser.vomit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">vomit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_type</span><span class="p">):</span> <span class="c1"># TOOL</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Safely move the index backward if the current token does not match expected_type.</span>
<span class="sd">        Used to &quot;unconsume&quot; a token.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        expected_type : str or list</span>
<span class="sd">            A single token type or a list of allowed token types.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if current token matches expected_type, False if index was decremented.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        DetailedError</span>
<span class="sd">            If argument type is invalid or index is out of range.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">typ</span> <span class="o">=</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_tokens</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expected_type</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">typ</span> <span class="o">!=</span> <span class="n">expected_type</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expected_type</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">token_type</span> <span class="ow">in</span> <span class="n">expected_type</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="n">token_type</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Expected list or string as argument&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Index out of range. Coud not decrement index to find </span><span class="si">{</span><span class="n">expected_type</span><span class="si">}</span><span class="s1">. Last item found: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">list_tokens</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="RPParser.eat_optional">
<a class="viewcode-back" href="../Parser.html#Parser.RPParser.eat_optional">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">eat_optional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_type</span><span class="p">):</span> <span class="c1"># TOOL</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Consume the next token if it matches expected_type; otherwise, skip.</span>
<span class="sd">        Syntax enforcement: optional, does not raise errors if token missing.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        expected_type : str</span>
<span class="sd">            The type of token that is optional.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str or bool</span>
<span class="sd">            The consumed token if present, False if token was skipped.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">token_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">()</span> 
        <span class="k">if</span> <span class="n">expected_type</span> <span class="o">==</span> <span class="n">token_type</span><span class="p">:</span> <span class="c1"># The token is optional but the user used it anyway -&gt; We consume</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">expected_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># We don&#39;t consume the next token</span>
            <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="RPParser.skip_spaces">
<a class="viewcode-back" href="../Parser.html#Parser.RPParser.skip_spaces">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">skip_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># TOOL</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Consume all consecutive SPACE tokens.</span>
<span class="sd">        Syntax enforcement: optional, does not raise errors if no SPACE tokens.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;SPACE&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eat_optional</span><span class="p">(</span><span class="s1">&#39;SPACE&#39;</span><span class="p">)</span> <span class="c1"># We expect to see a &#39;SPACE&#39; but it&#39;s okay if there isn&#39;t</span></div>
</div>

                




<div class="viewcode-block" id="SimpleParser">
<a class="viewcode-back" href="../Parser.html#Parser.SimpleParser">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SimpleParser</span><span class="p">(</span><span class="n">RPParser</span><span class="p">):</span> <span class="c1"># All method in this class cannot exist inside syntax_handler of dispatch parser (to verify) because they don&#39;t return args</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provides simple parsing methods for parsing without a dispatch table.</span>
<span class="sd">    This class inherits all the TOOLS from RPParser</span>

<span class="sd">    These methods implement fundamental parsing logic. They serve as the base for</span>
<span class="sd">    more complex parsers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_tokens</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">list_tokens</span><span class="p">)</span>

<div class="viewcode-block" id="SimpleParser.parse_string">
<a class="viewcode-back" href="../Parser.html#Parser.SimpleParser.parse_string">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Verify that the next token respects string syntax.</span>
<span class="sd">        Syntax enforcement: Raises DetailedError if token is not a valid STRING.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        StringNode</span>
<span class="sd">            AST node representing the string value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;STRING&#39;</span><span class="p">)</span>
        <span class="n">token_value</span> <span class="o">=</span> <span class="n">__GET__VALUE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">StringNode</span><span class="p">(</span><span class="n">token_value</span><span class="p">)</span> </div>


<div class="viewcode-block" id="SimpleParser.parse_user">
<a class="viewcode-back" href="../Parser.html#Parser.SimpleParser.parse_user">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_user</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Parse a user-defined identifier token.</span>
<span class="sd">        Syntax: USER &lt;user_variable&gt;</span>
<span class="sd">        Syntax enforcement: Raises DetailedError if token is not a valid identifier.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        UserNode</span>
<span class="sd">            AST node representing the user identifier.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;USER&#39;</span><span class="p">)</span>
        <span class="n">token_value</span> <span class="o">=</span> <span class="n">__GET__VALUE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="n">regex_user</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;^[A-Za-z_][A-Za-z0-9_]*$&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">regex_user</span><span class="p">,</span> <span class="n">token_value</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Wrong syntax used for variable: &#39;</span><span class="si">{</span><span class="n">token_value</span><span class="si">}</span><span class="s2">&#39; is not a valid identifier&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">UserNode</span><span class="p">(</span><span class="n">token_value</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="SimpleParser.parse_comment">
<a class="viewcode-back" href="../Parser.html#Parser.SimpleParser.parse_comment">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_comment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Consume a comment line. Consume everything until NEWLINE token or end of token list (self.EOF).</span>
<span class="sd">        Syntax enforcement: Optional, does not raise errors for comment content.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;COMMENT&#39;</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eat_skip_until</span><span class="p">(</span><span class="s1">&#39;NEWLINE&#39;</span><span class="p">)</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">val</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eat_skip_until</span><span class="p">(</span><span class="s1">&#39;NEWLINE&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SimpleParser.eof_line">
<a class="viewcode-back" href="../Parser.html#Parser.SimpleParser.eof_line">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">eof_line</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># BASIC_PARSER (it cannot be DISPATCH_PARSER because every DISPATCH_PARSER use it)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Handle the end of a line after reading a statement.</span>
<span class="sd">        Syntax enforcement: Raises DetailedError for unexpected tokens.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">token_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>

        <span class="c1"># HANDLING whether we have a COMMENT token or a NEWLINE token</span>
        <span class="n">token_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">token_type</span> <span class="o">==</span> <span class="s1">&#39;COMMENT&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parse_comment</span><span class="p">()</span> 
        <span class="k">elif</span> <span class="n">token_type</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span><span class="p">:</span> 
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">token_type</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;token = &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_tokens</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">])</span>
            <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected token: </span><span class="si">{</span><span class="n">token_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="SimpleParser.parse_jump">
<a class="viewcode-back" href="../Parser.html#Parser.SimpleParser.parse_jump">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_jump</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># BASIC_PARSER</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Parse a &#39;jump&#39; statement.</span>
<span class="sd">        Syntax: jump &lt;label_name&gt;</span>
<span class="sd">        Syntax enforcement: Raises DetailedError if invalid token or syntax.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        JumpNode</span>
<span class="sd">            AST node representing the jump statement.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="s1">&#39;jump&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        
        <span class="c1"># HANDLING USER token</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_user</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        
        <span class="c1"># HANDLING end of line</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">JumpNode</span><span class="p">(</span><span class="n">label_name</span><span class="o">=</span><span class="n">val</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="SimpleParser.parse_return">
<a class="viewcode-back" href="../Parser.html#Parser.SimpleParser.parse_return">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_return</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># BASIC_PARSER</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Parse a &#39;return&#39; statement.</span>
<span class="sd">        Syntax: return [value]</span>
<span class="sd">            [argument]: argument is optional</span>
<span class="sd">        Syntax enforcement: Raises DetailedError if token sequence invalid.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ReturnNode</span>
<span class="sd">            AST node representing the return statement with optional value.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="s1">&#39;return&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>

        <span class="c1"># HANDLING the situation where the syntax is done </span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;COMMENT&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ReturnNode</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        
        <span class="c1"># HANDLING USER token</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_user</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        
        <span class="c1"># HANDLING end of line</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ReturnNode</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">val</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="SimpleParser.parse_stop">
<a class="viewcode-back" href="../Parser.html#Parser.SimpleParser.parse_stop">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># BASIC_PARSER</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Parse a &#39;stop&#39; statement for music or sound.</span>
<span class="sd">        Syntax: stop [music|sound] [fadeout [duration]]</span>
<span class="sd">            [argument]: argument is optional</span>
<span class="sd">            arg1|arg2: either arg1 or arg2 is expected</span>
<span class="sd">        Syntax enforcement: Raises DetailedError if syntax or values are invalid.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        StopNode</span>
<span class="sd">            AST node representing the stop statement, with optional audio type and fadeout duration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        
        <span class="c1"># HANDLING the situation where the syntax is done </span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;COMMENT&#39;</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">StopNode</span><span class="p">()</span>
        
        <span class="c1"># HANDLING whether we have music or sound KEYWORD token</span>
        <span class="n">audio_val</span> <span class="o">=</span> <span class="n">__GET__VALUE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">audio_val</span> <span class="o">==</span> <span class="s1">&#39;music&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="s1">&#39;music&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">audio_val</span> <span class="o">==</span> <span class="s1">&#39;sound&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="s1">&#39;sound&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">audio_val</span> <span class="o">==</span> <span class="s1">&#39;voice&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="s1">&#39;voice&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Stop syntax error. Expected either music or sound or voice but got </span><span class="si">{</span><span class="n">audio_val</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="c1"># HANDLING the situation where the syntax is done </span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;COMMENT&#39;</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">StopNode</span><span class="p">(</span><span class="n">audio_type</span><span class="o">=</span><span class="n">audio_val</span><span class="p">)</span>
        
        <span class="c1"># HANDLING if we have a fadeout</span>
        <span class="n">effect_val</span> <span class="o">=</span> <span class="n">__GET__VALUE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">effect_val</span> <span class="o">!=</span> <span class="s1">&#39;fadeout&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Stop syntax error. Expected fadeout but got </span><span class="si">{</span><span class="n">effect_val</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;BUILTIN&#39;</span><span class="p">,</span> <span class="n">effect_val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>

        <span class="c1"># HANDLING the situation where the syntax is done </span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;COMMENT&#39;</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">StopNode</span><span class="p">(</span><span class="n">audio_type</span><span class="o">=</span><span class="n">audio_val</span><span class="p">,</span> <span class="n">fadeout</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># 2 sec is default value of fadeout when user does not precise</span>

        <span class="c1"># HANDLING duration of fade effect</span>
        <span class="n">duration_val</span> <span class="o">=</span> <span class="n">__GET__VALUE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+(\.\d+)?&#39;</span><span class="p">,</span> <span class="n">duration_val</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="s1">&#39;Stop syntax error. Expected a float number for fadeout effect.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;DOT&#39;</span><span class="p">,</span> <span class="n">duration_val</span><span class="p">)</span>

        <span class="c1"># HANDLING end of line</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">StopNode</span><span class="p">(</span><span class="n">audio_type</span><span class="o">=</span><span class="n">audio_val</span><span class="p">,</span> <span class="n">fadeout</span><span class="o">=</span><span class="n">duration_val</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="SimpleParser.parse_function_call">
<a class="viewcode-back" href="../Parser.html#Parser.SimpleParser.parse_function_call">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_function_call</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># BASIC_PARSER</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Parse a function call expression.</span>
<span class="sd">        Syntax: &lt;FUNCTION_NAME&gt;(&lt;ARG1&gt; [&lt;ARG2&gt;, ..., &lt;ARGN&gt;])</span>
<span class="sd">            [argument]: argument is optional</span>
<span class="sd">        Syntax enforcement: Raises DetailedError if invalid argument type or missing RPAREN.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        FunctionCallNode</span>
<span class="sd">            AST node representing the function call with arguments and keyword assignments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">function_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;FUNCTION&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;LPAREN&#39;</span><span class="p">)</span>
        
        <span class="n">ast_args_list</span> <span class="o">=</span> <span class="p">[]</span> 
        <span class="n">ast_kwargs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># HANDLING all the arguments inside the function (between the parenthesis)</span>
        <span class="n">accepted_types</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;USER&#39;</span><span class="p">,</span> <span class="s1">&#39;STRING&#39;</span><span class="p">,</span> <span class="s1">&#39;COMMA&#39;</span><span class="p">,</span> <span class="s1">&#39;SPACE&#39;</span><span class="p">,</span> <span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span> <span class="s1">&#39;KEYWORD&#39;</span><span class="p">]</span>
        <span class="n">accepted_values_KEYWORD</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;image&#39;</span><span class="p">]</span>
        <span class="k">while</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_tokens</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;RPAREN&#39;</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">arg_token_type</span><span class="p">,</span> <span class="n">arg_token_value</span> <span class="o">=</span> <span class="n">__BREAK__TOKEN__</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">arg_token_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">accepted_types</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Wrong argument in function call. Expected either </span><span class="si">{</span><span class="n">accepted_types</span><span class="si">}</span><span class="s2"> arguments but got </span><span class="si">{</span><span class="n">arg_token_type</span><span class="si">}</span><span class="s2"> instead&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">arg_token_type</span> <span class="o">==</span> <span class="s1">&#39;KEYWORD&#39;</span> <span class="ow">and</span> <span class="n">arg_token_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">accepted_values_KEYWORD</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Wrong argument in function call. Expected </span><span class="si">{</span><span class="n">accepted_values_KEYWORD</span><span class="si">}</span><span class="s2"> arguments but got </span><span class="si">{</span><span class="n">arg_token_value</span><span class="si">}</span><span class="s2"> instead&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># We are handling an arg or a kwargs</span>
                <span class="k">if</span> <span class="n">arg_token_type</span> <span class="o">==</span> <span class="s1">&#39;USER&#39;</span><span class="p">:</span>
                    <span class="n">ast_args_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_user</span><span class="p">())</span>
                <span class="k">elif</span> <span class="n">arg_token_type</span> <span class="o">==</span> <span class="s1">&#39;STRING&#39;</span><span class="p">:</span>
                    <span class="n">ast_args_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_string</span><span class="p">())</span>
                <span class="k">elif</span> <span class="n">arg_token_type</span> <span class="o">==</span> <span class="s1">&#39;ASSIGN&#39;</span><span class="p">:</span>
                    <span class="n">ast_kwargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_assign_local</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># We are not storing this information:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">arg_token_type</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_tokens</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Wrong argument in function call. Expected RPAREN but got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">list_tokens</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_tokens</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> instead.&quot;</span><span class="p">)</span>
        
        <span class="c1"># HANDLING end of function syntax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;RPAREN&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">FunctionCallNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">__GET__VALUE__TOKEN__</span><span class="p">(</span><span class="n">function_token</span><span class="p">),</span> <span class="n">args</span><span class="o">=</span><span class="n">ast_args_list</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">ast_kwargs</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="SimpleParser.parse_fadein">
<a class="viewcode-back" href="../Parser.html#Parser.SimpleParser.parse_fadein">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_fadein</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Parse a &#39;fadein&#39; statement.</span>
<span class="sd">        Syntax: fadein &lt;duration&gt;</span>
<span class="sd">        Syntax enforcement: Raises DetailedError if duration is missing or invalid.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        FadeInNode</span>
<span class="sd">            AST node representing the fade-in statement.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;fadein&#39;</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="c1"># Default  value if not precised by USER</span>
            <span class="s1">&#39;loop&#39;</span><span class="p">:</span> <span class="kc">True</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;BUILTIN&#39;</span><span class="p">,</span> <span class="s1">&#39;fadein&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>

        <span class="c1"># HANDLING the situation where the syntax is done </span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;COMMENT&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">args</span>
        
        <span class="c1"># HANDLING fadein or loop</span>
        <span class="n">token_type</span><span class="p">,</span> <span class="n">token_val</span> <span class="o">=</span> <span class="n">__BREAK__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">token_val</span> <span class="o">!=</span> <span class="s1">&#39;loop&#39;</span> <span class="ow">and</span> <span class="n">token_type</span> <span class="o">!=</span> <span class="s1">&#39;DOT&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Syntax error fadein. Expected either a float or loop but got </span><span class="si">{</span><span class="n">token</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">token_val</span> <span class="o">==</span> <span class="s1">&#39;loop&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="s1">&#39;loop&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>
            <span class="n">args</span><span class="p">[</span><span class="s1">&#39;loop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="n">args</span>
        
        <span class="n">args</span><span class="p">[</span><span class="s1">&#39;fadein&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">token_val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;DOT&#39;</span><span class="p">,</span> <span class="n">token_val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        
        <span class="c1"># HANDLING the situation where the syntax is done </span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;COMMENT&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">args</span>
        
        <span class="c1"># HANDLING loop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="s1">&#39;loop&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s1">&#39;loop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">args</span></div>


<div class="viewcode-block" id="SimpleParser.parse_play">
<a class="viewcode-back" href="../Parser.html#Parser.SimpleParser.parse_play">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_play</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># BASIC_PARSER</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Parse a &#39;play&#39; statement for music or sound.</span>
<span class="sd">        Syntax: play (music|sound|voice) audio_file [fadein [time]] [loop]</span>
<span class="sd">            [argument]: optional</span>
<span class="sd">            arg1|arg2|arg3: one of these audio types is expected</span>
<span class="sd">        Syntax enforcement: Raises DetailedError if syntax or arguments are invalid.</span>

<span class="sd">        Tips: </span>
<span class="sd">        music is for background music</span>
<span class="sd">        sound is for SFX</span>
<span class="sd">        voice is for character&#39;s voice</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PlayNode</span>
<span class="sd">            AST node representing the play statement with optional fade-in duration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="s1">&#39;play&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>

        <span class="c1"># HANDLING whether we have music, voice or sound</span>
        <span class="n">token_type</span><span class="p">,</span> <span class="n">token_val</span> <span class="o">=</span> <span class="n">__BREAK__TOKEN__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">token_val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;music&#39;</span><span class="p">,</span> <span class="s1">&#39;voice&#39;</span><span class="p">,</span> <span class="s1">&#39;sound&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Syntax error play. Expected music, sound or voice but got </span><span class="si">{</span><span class="n">token_val</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="n">_audio_type</span> <span class="o">=</span> <span class="n">token_val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="n">token_val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>

        <span class="c1"># HANDLING the audio file (correspond to &#39;path&#39; in the syntax)</span>
        <span class="n">_audiofile</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">token_type</span><span class="p">,</span> <span class="n">token_val</span> <span class="o">=</span> <span class="n">__BREAK__TOKEN__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">token_type</span> <span class="o">==</span> <span class="s1">&#39;STRING&#39;</span><span class="p">:</span>
            <span class="n">_audiofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_string</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># it must be a user token</span>
            <span class="n">_audiofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_user</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        
        <span class="c1"># HANDLING the situation where the syntax is done </span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;COMMENT&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PlayNode</span><span class="p">(</span><span class="n">audio_type</span><span class="o">=</span><span class="n">_audio_type</span><span class="p">,</span> <span class="n">audio_file</span><span class="o">=</span><span class="n">_audiofile</span><span class="p">)</span>
        
        <span class="c1"># HANDLING loop or fadein</span>
        <span class="n">token_type</span><span class="p">,</span> <span class="n">token_val</span> <span class="o">=</span> <span class="n">__BREAK__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">token_val</span> <span class="o">!=</span> <span class="s1">&#39;fadein&#39;</span> <span class="ow">and</span> <span class="n">token_val</span> <span class="o">!=</span> <span class="s1">&#39;loop&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Syntax error play. Expected fadein or loop but got </span><span class="si">{</span><span class="n">token_val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">token_val</span> <span class="o">==</span> <span class="s1">&#39;loop&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">token_type</span><span class="p">,</span> <span class="n">token_val</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">PlayNode</span><span class="p">(</span><span class="n">audio_type</span><span class="o">=</span><span class="n">_audio_type</span><span class="p">,</span> <span class="n">audio_file</span><span class="o">=</span><span class="n">_audiofile</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="n">args_fadein</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_fadein</span><span class="p">()</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">PlayNode</span><span class="p">(</span><span class="n">audio_type</span><span class="o">=</span><span class="n">_audio_type</span><span class="p">,</span> <span class="n">audio_file</span><span class="o">=</span><span class="n">_audiofile</span><span class="p">,</span> <span class="n">fadein</span><span class="o">=</span><span class="n">args_fadein</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fadein&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="p">,</span><span class="n">loop</span><span class="o">=</span><span class="n">args_fadein</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;loop&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span></div>


<div class="viewcode-block" id="SimpleParser.parse_assign_global">
<a class="viewcode-back" href="../Parser.html#Parser.SimpleParser.parse_assign_global">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_assign_global</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># BASIC_PARSER (not used currently)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Parse a &#39;global assignment&#39; statement.</span>
<span class="sd">        Syntax: global &lt;identifier&gt; = &lt;expression&gt;</span>
<span class="sd">        Syntax enforcement: Raises DetailedError if identifier or expression is missing.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AssignGlobalNode</span>
<span class="sd">            AST node representing a global variable assignment.</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="n">LHS</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">RHS</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># HANDLING USER token</span>
        <span class="c1"># We must decrement self.idx until we see &#39;USER&#39; or a &#39;KEYWORD&#39;</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">vomit</span><span class="p">(</span><span class="s1">&#39;USER&#39;</span><span class="p">):</span> <span class="c1"># We accept at most 1 space between USER and ASSIGN tokens</span>
            <span class="k">pass</span> <span class="c1"># What if there are two &#39;USER&#39; tokens before ASSIGN ? The function who calls Assign must verify it it self.</span>

        <span class="c1"># Left side of ASSIGN (LHS):</span>
        <span class="n">LHS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_user</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
       
        <span class="c1"># HANDLING whether we have USER, STRING or FUNCTION token</span>
        <span class="n">token_type</span> <span class="o">=</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span> <span class="c1"># Important for this to work: we must have ONE instance of the class that contains list_tokens and all the other classes used for the parsing in this project must inherit it</span>
        <span class="k">if</span> <span class="n">token_type</span> <span class="o">==</span> <span class="s1">&#39;USER&#39;</span><span class="p">:</span>
            <span class="n">RHS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_user</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">token_type</span> <span class="o">==</span> <span class="s1">&#39;STRING&#39;</span><span class="p">:</span>
            <span class="n">RHS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_string</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">token_type</span> <span class="o">==</span> <span class="s1">&#39;FUNCTION&#39;</span><span class="p">:</span>
            <span class="n">RHS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_function_call</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Syntax error. Expected one of the following as an argument: FUNCTION, STRING or USER but got </span><span class="si">{</span><span class="n">token_type</span><span class="si">}</span><span class="s2"> instead.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">AssignNode</span><span class="p">(</span>
            <span class="n">LHS</span> <span class="o">=</span> <span class="n">LHS</span><span class="p">,</span>
            <span class="n">RHS</span> <span class="o">=</span> <span class="n">RHS</span>
        <span class="p">)</span></div>

    
<div class="viewcode-block" id="SimpleParser.parse_assign_local">
<a class="viewcode-back" href="../Parser.html#Parser.SimpleParser.parse_assign_local">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_assign_local</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># assign used inside function call</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Parse a &#39;local assignment&#39; statement.</span>
<span class="sd">        Syntax: &lt;identifier&gt; = &lt;expression&gt;</span>
<span class="sd">        Syntax enforcement: Raises DetailedError if identifier or expression is missing.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AssignLocalNode</span>
<span class="sd">            AST node representing a local variable assignment.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">LHS</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">RHS</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># HANDLING color or image </span>
        <span class="c1"># We must decrement self.idx until we see &#39;color&#39; or a &#39;image&#39;</span>
        <span class="n">expected_token</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="s1">&#39;USER&#39;</span><span class="p">]</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">vomit</span><span class="p">(</span><span class="n">expected_token</span><span class="p">):</span> <span class="c1"># We accept at most 1 space between USER and ASSIGN tokens</span>
            <span class="k">pass</span> <span class="c1"># What if there are two &#39;USER&#39; tokens before ASSIGN ? The function who calls Assign must verify it it self.</span>
        <span class="n">typ</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">__BREAK__TOKEN__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

        <span class="c1"># HANDLING left side of ASSIGN (LHS):</span>
        <span class="n">backup_LHS_value</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;USER&#39;</span><span class="p">:</span>
            <span class="n">LHS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_user</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;KEYWORD&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">val</span> <span class="o">!=</span> <span class="s1">&#39;color&#39;</span> <span class="ow">and</span> <span class="n">val</span> <span class="o">!=</span> <span class="s1">&#39;image&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="s1">&#39;Error function assign local. Expected either color or image.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="n">LHS</span> <span class="o">=</span> <span class="n">KeywordNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        
        <span class="c1"># HANDLING RHS depending on what we obtained in LHS</span>
        <span class="n">token_type</span><span class="p">,</span> <span class="n">token_value</span> <span class="o">=</span> <span class="n">__BREAK__TOKEN__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span> <span class="c1"># Important for this to work: we must have ONE instance of the class that contains list_tokens and all the other classes used for the parsing in this project must inherit it</span>
        <span class="k">if</span> <span class="n">token_type</span> <span class="o">!=</span> <span class="s1">&#39;STRING&#39;</span> <span class="ow">and</span> <span class="n">token_type</span> <span class="o">!=</span> <span class="s1">&#39;USER&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Syntax error. Expected one of the following as an argument: STRING or USER but got </span><span class="si">{</span><span class="n">token_type</span><span class="si">}</span><span class="s2"> instead.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">backup_LHS_value</span> <span class="o">==</span> <span class="s1">&#39;color&#39;</span><span class="p">:</span>
            <span class="n">RHS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_string</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">backup_LHS_value</span> <span class="o">==</span> <span class="s1">&#39;image&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">token_type</span> <span class="o">==</span> <span class="s1">&#39;USER&#39;</span><span class="p">:</span>
                <span class="n">RHS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_user</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">RHS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_string</span><span class="p">()</span>

        
        <span class="k">return</span> <span class="n">AssignNode</span><span class="p">(</span>
            <span class="n">LHS</span> <span class="o">=</span> <span class="n">LHS</span><span class="p">,</span>
            <span class="n">RHS</span> <span class="o">=</span> <span class="n">RHS</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SimpleParser.parse_image">
<a class="viewcode-back" href="../Parser.html#Parser.SimpleParser.parse_image">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_image</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># BASIC_PARSER</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Parse an &#39;image&#39; statement defining a scene image.</span>
<span class="sd">        Syntax: image &lt;identifier&gt; [as &lt;alias&gt;] = &lt;path&gt;</span>
<span class="sd">            [argument]: argument is optional</span>
<span class="sd">        Syntax enforcement: Raises DetailedError if syntax, alias, or path are invalid.</span>

<span class="sd">        Tips:</span>
<span class="sd">        An image identifier contains at least one USER token: the first token is the </span>
<span class="sd">        main name, and any subsequent tokens are optional tags for variants. </span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImageNode</span>
<span class="sd">            AST node representing the image declaration with optional alias.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="s1">&#39;image&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>

        <span class="c1"># HANDLING syntax &#39;image_expression -&gt; n * SPACE&#39;</span>
        <span class="n">img_expression</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Browsing through the line until &#39;ASSIGN&#39;:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;token_type = self.eat()</span>
<span class="sd">        while (token_type != self.EOF and token_type != &#39;ASSIGN&#39;):</span>
<span class="sd">            if token_type == &#39;USER&#39;:</span>
<span class="sd">                self.vomit(&#39;USER&#39;) # We decrement self.idx because we already read it</span>
<span class="sd">                img_expression.append(self.parse_user())</span>
<span class="sd">            token_type = self.eat()</span>
<span class="sd">        self.vomit(&#39;ASSIGN&#39;) # We need to decrement again self.idx because we used self.eat&quot;&quot;&quot;</span>
        
        <span class="n">token_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eat_skip_until</span><span class="p">(</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span> <span class="n">return_type_found</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">token_type</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="ow">and</span> <span class="n">token_type</span> <span class="o">!=</span> <span class="s1">&#39;ASSIGN&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">token_type</span> <span class="o">==</span> <span class="s1">&#39;USER&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vomit</span><span class="p">(</span><span class="s1">&#39;USER&#39;</span><span class="p">)</span> <span class="c1"># We already ate &#39;USER&#39; so we need to decrement self.idx before calling parse_user</span>
                <span class="n">img_expression</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_user</span><span class="p">())</span>
            <span class="n">token_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eat_skip_until</span><span class="p">(</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span> <span class="n">return_type_found</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">img_expression</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="s1">&#39;Syntax error for parse_image. Expected at least one USER token.&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        
        <span class="c1"># HANDLING string or user node:</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">token_type</span> <span class="o">=</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">token_type</span> <span class="o">!=</span> <span class="s1">&#39;USER&#39;</span> <span class="ow">and</span> <span class="n">token_type</span> <span class="o">!=</span> <span class="s1">&#39;STRING&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;type = &#39;</span><span class="p">,</span> <span class="n">token_type</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="s1">&#39;Syntax error image. Expected STRING or USER.&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">token_type</span> <span class="o">==</span> <span class="s1">&#39;STRING&#39;</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_string</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">ImageNode</span><span class="p">(</span><span class="n">image_expression</span><span class="o">=</span><span class="n">img_expression</span><span class="p">,</span> <span class="n">string_path</span><span class="o">=</span><span class="n">path</span><span class="p">)</span>
        
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_user</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ImageNode</span><span class="p">(</span><span class="n">image_expression</span><span class="o">=</span><span class="n">img_expression</span><span class="p">,</span> <span class="n">user_var</span><span class="o">=</span><span class="n">path</span><span class="p">)</span></div>
</div>

    







<div class="viewcode-block" id="DispatchParser">
<a class="viewcode-back" href="../Parser.html#Parser.DispatchParser">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DispatchParser</span><span class="p">(</span><span class="n">SimpleParser</span><span class="p">):</span> <span class="c1"># Must inherit SimpleParser later on</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parser class using dispatch tables to handle more complex parser methods.</span>

<span class="sd">    DispatchParser implements a recursive dispatch table system for parsing RenPy-style syntax.</span>
<span class="sd">    Children dispatch parsers handle a keyword or token type, optionally take an &#39;args&#39; dictionary, </span>
<span class="sd">    perform parsing, and update &#39;args&#39; before returning it to the parent parser.</span>
<span class="sd">    Parent dispatch parsers handle top-level constructs and return fully-formed AST nodes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_tokens</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">list_tokens</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_parser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_syntax_handler</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Retrieves the appropriate parser method from a dispatch table based on the next token in the input stream.</span>
<span class="sd">        Looks for a match using either the token type or the token value. Raises a DetailedError if no match is found.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        _syntax_handler: dict</span>
<span class="sd">            A dictionary mapping token types or values to corresponding parser methods.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        callable</span>
<span class="sd">            The parser method corresponding to the next token.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parse_method</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">dispatch_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_syntax_handler</span><span class="p">]</span>
        <span class="n">token_peek</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">key_type</span><span class="p">,</span> <span class="n">key_value</span> <span class="o">=</span> <span class="n">__BREAK__TOKEN__</span><span class="p">(</span><span class="n">token_peek</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key_type</span> <span class="ow">in</span> <span class="n">dispatch_idx</span><span class="p">:</span>
            <span class="n">parse_method</span> <span class="o">=</span> <span class="n">_syntax_handler</span><span class="p">[</span><span class="n">key_type</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">key_value</span> <span class="ow">in</span> <span class="n">dispatch_idx</span><span class="p">:</span>
            <span class="n">parse_method</span> <span class="o">=</span> <span class="n">_syntax_handler</span><span class="p">[</span><span class="n">key_value</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Syntax error. Expected one of the following as an argument: </span><span class="si">{</span><span class="n">dispatch_idx</span><span class="si">}</span><span class="s2"> but got </span><span class="si">{</span><span class="n">token_peek</span><span class="si">}</span><span class="s2"> instead.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">parse_method</span>

<div class="viewcode-block" id="DispatchParser.update_args">
<a class="viewcode-back" href="../Parser.html#Parser.DispatchParser.update_args">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syntax_handler</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Updates the `args` dictionary by invoking the parser method retrieved from `syntax_handler`.  </span>
<span class="sd">        The method distinguishes between two types of parser methods:</span>
<span class="sd">        - If the parser method is bound to `SimpleParser`, it is called without arguments and its result is stored in `args` under the given key.</span>
<span class="sd">        - If the parser method is a `DispatchParser`, it is called with `args` and expected to return an updated dictionary.</span>
<span class="sd">        - Raises a `DetailedError` if the parser method is neither type.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        syntax_handler: dict</span>
<span class="sd">            Dispatch table mapping token types or values to parser methods.</span>

<span class="sd">        args: dict</span>
<span class="sd">            The current dictionary of arguments to update.</span>

<span class="sd">        key: str, optional</span>
<span class="sd">            The key under which to store the result when calling a `SimpleParser` method. Default is an empty string.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            The updated `args` dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parser_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parser</span><span class="p">(</span><span class="n">syntax_handler</span><span class="p">)</span>

        <span class="c1"># HANDLE SimpleParser</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">parser_method</span><span class="p">,</span> <span class="s2">&quot;__self__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parser_method</span><span class="o">.</span><span class="vm">__self__</span><span class="p">,</span> <span class="n">SimpleParser</span><span class="p">):</span>
            <span class="n">args</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">parser_method</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">args</span>

        <span class="c1"># HANDLE DispatchParser</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parser_method</span><span class="p">,</span> <span class="n">DispatchParser</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">parser_method</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># HANDLE neither</span>
        <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span> <span class="c1"># On est pas cens arriv ici</span>
            <span class="sa">f</span><span class="s2">&quot;Parser method attendu: SimpleParser ou DispatchParser. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Type reu: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">parser_method</span><span class="p">)</span><span class="si">}</span><span class="s2">. Mthode: </span><span class="si">{</span><span class="n">parser_method</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="DispatchParser.update_args_simpleparser">
<a class="viewcode-back" href="../Parser.html#Parser.DispatchParser.update_args_simpleparser">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_args_simpleparser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syntax_handler</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">check_with_type</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Updates the `args` dictionary by calling a `SimpleParser` method retrieved from `syntax_handler`.  </span>
<span class="sd">        Typically used by dispatch parser methods that expect only `SimpleParser` methods in their syntax handler.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        syntax_handler: dict</span>
<span class="sd">            Dispatch table mapping token types or values to parser methods.</span>

<span class="sd">        args: dict</span>
<span class="sd">            The current dictionary of arguments to update.</span>

<span class="sd">        key: str, optional</span>
<span class="sd">            The key under which to store the result of the `SimpleParser` method. Default is an empty string.</span>

<span class="sd">        check_with_type: bool, optional</span>
<span class="sd">            If True, `_get_parser` will prioritize matching the token type when selecting the parser method. Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            The updated `args` dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parser_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parser</span><span class="p">(</span><span class="n">syntax_handler</span><span class="p">,</span> <span class="n">check_with_type</span><span class="p">)</span>
        <span class="n">args</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">parser_method</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">args</span></div>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_args</span><span class="p">,</span> <span class="n">_syntax_handler</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Performs a dispatch based on the next token for &#39;children&#39; dispatch parser methods.  </span>
<span class="sd">        Checks the next token&#39;s type and value against the provided `_syntax_handler` dispatch table.  </span>
<span class="sd">        Calls the corresponding parser method from `_syntax_handler` with `_args`.  </span>
<span class="sd">        Raises `DetailedError` if no matching key is found in the dispatch table.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        _args: dict</span>
<span class="sd">            Dictionary of arguments to pass to the selected parser method.</span>

<span class="sd">        _syntax_handler: dict</span>
<span class="sd">            Dispatch table mapping token types or values to parser methods.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            The updated arguments dictionary after the dispatched parser method has been applied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dispatch_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_syntax_handler</span><span class="p">]</span>
        <span class="n">token_peek</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">key_type</span><span class="p">,</span> <span class="n">key_value</span> <span class="o">=</span> <span class="n">__BREAK__TOKEN__</span><span class="p">(</span><span class="n">token_peek</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key_type</span> <span class="ow">in</span> <span class="n">dispatch_idx</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">_syntax_handler</span><span class="p">[</span><span class="n">key_type</span><span class="p">](</span><span class="n">_args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key_value</span> <span class="ow">in</span> <span class="n">dispatch_idx</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">_syntax_handler</span><span class="p">[</span><span class="n">key_value</span><span class="p">](</span><span class="n">_args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Scene syntax error. Expected one of the following as an argument: </span><span class="si">{</span><span class="n">dispatch_idx</span><span class="si">}</span><span class="s2"> but got </span><span class="si">{</span><span class="n">token_peek</span><span class="si">}</span><span class="s2"> instead.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">args</span>
    
<div class="viewcode-block" id="DispatchParser.parse_define">
<a class="viewcode-back" href="../Parser.html#Parser.DispatchParser.parse_define">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_define</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Parses a `define` statement of the form `define &lt;USER&gt; = &lt;expression&gt;`.  </span>
<span class="sd">        The right-hand side `&lt;expression&gt;` can be:</span>
<span class="sd">        - A STRING (e.g., `&quot;Eileen&quot;`)</span>
<span class="sd">        - A USER (variable, e.g., `True`, `None`, `my_var`)</span>
<span class="sd">        - A FUNCTION call (e.g., `Character(&quot;Eileen&quot;, color=&quot;#fff&quot;)`)</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DefineNode</span>
<span class="sd">            AST node representing the `define` statement, containing:</span>
<span class="sd">            - `id`: the user-defined identifier</span>
<span class="sd">            - `value`: the parsed expression on the right-hand side</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="s1">&#39;define&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        <span class="n">id_define</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_user</span><span class="p">()</span> <span class="c1"># Must be the same as ast_assign.__getattribute__(&quot;LHS&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>

        <span class="n">args_define</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="n">id_define</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>

        <span class="c1"># HANDLING expression on RHS of assign using a dispatch table:</span>
        <span class="n">syntax_handler</span> <span class="o">=</span> <span class="p">{</span> <span class="c1"># We use a dispatch_table instead of if/else if imbriqus</span>
            <span class="s2">&quot;STRING&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_string</span><span class="p">,</span>
            <span class="s2">&quot;USER&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_user</span><span class="p">,</span>
            <span class="s2">&quot;FUNCTION&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_function_call</span>
        <span class="p">}</span>

        <span class="n">args_define</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_args</span><span class="p">(</span><span class="n">syntax_handler</span><span class="p">,</span> <span class="n">args_define</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">DefineNode</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">args_define</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">value</span><span class="o">=</span><span class="n">args_define</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span></div>


<div class="viewcode-block" id="DispatchParser.parse_with">
<a class="viewcode-back" href="../Parser.html#Parser.DispatchParser.parse_with">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Parses a `with` statement that specifies a transition.  </span>
<span class="sd">        The syntax handled is:</span>

<span class="sd">            with &lt;transition&gt;</span>

<span class="sd">        Where `&lt;transition&gt;` can be:</span>
<span class="sd">        - A BUILTIN token (predefined transition)</span>
<span class="sd">        - A USER-defined identifier</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        args: dict, optional</span>
<span class="sd">            Dictionary to update with the parsed transition under the key `&#39;transition&#39;`.  </span>
<span class="sd">            If not provided, the method returns only the parsed transition AST node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TransitionNode or dict</span>
<span class="sd">            - If `args` is provided: the updated `args` dictionary containing the parsed transition.</span>
<span class="sd">            - If `args` is None: the `TransitionNode` representing the parsed transition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">transition_ast</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="c1"># HANDLING the syntax &#39;with -&gt; n * SPACE&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="s1">&#39;with&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        
        <span class="c1"># HANDLING the syntax &#39;transition -&gt; n * SPACE&#39; # transition can be defined by user or a BUILTIN token </span>
        <span class="n">token_type</span><span class="p">,</span> <span class="n">token_value</span> <span class="o">=</span> <span class="n">__BREAK__TOKEN__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">token_type</span> <span class="o">==</span> <span class="s1">&#39;BUILTIN&#39;</span><span class="p">:</span>
            <span class="n">transition_ast</span> <span class="o">=</span> <span class="n">TransitionNode</span><span class="p">(</span><span class="n">transition_name</span><span class="o">=</span><span class="n">token_value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;BUILTIN&#39;</span><span class="p">,</span> <span class="n">token_value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token_type</span> <span class="o">==</span> <span class="s1">&#39;USER&#39;</span><span class="p">:</span>
            <span class="n">transition_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_user</span><span class="p">()</span>
            <span class="n">transition_ast</span> <span class="o">=</span> <span class="n">TransitionNode</span><span class="p">(</span><span class="n">transition_name</span><span class="o">=</span><span class="n">transition_value</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>

        <span class="c1"># UPDATING args</span>
        <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transition_ast</span>
            <span class="k">return</span> <span class="n">args</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">transition_ast</span> </div>

            
<div class="viewcode-block" id="DispatchParser.parse_onlayer">
<a class="viewcode-back" href="../Parser.html#Parser.DispatchParser.parse_onlayer">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_onlayer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Parses an `onlayer` statement, which assigns a layer to an element and optionally handles a transition.  </span>
<span class="sd">        The syntax handled is:</span>

<span class="sd">            onlayer &lt;layer&gt;</span>
<span class="sd">            onlayer &lt;layer&gt; with &lt;transition&gt;</span>

<span class="sd">        Where `&lt;layer&gt;` can be:</span>
<span class="sd">        - The BUILTIN layer `&#39;master&#39;`</span>
<span class="sd">        - A USER-defined layer identifier</span>

<span class="sd">        The method also optionally handles a `with` clause to specify a transition using a dispatch table.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        args: dict</span>
<span class="sd">            Dictionary of arguments to update. The parsed layer is stored under the key `&#39;layer&#39;`.  </span>
<span class="sd">            If a `with` transition is present, it will also be added under the key `&#39;transition&#39;`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            The updated `args` dictionary containing:</span>
<span class="sd">            - `&#39;layer&#39;`: the parsed `LayerNode`</span>
<span class="sd">            - `&#39;transition&#39;` (optional): the parsed `TransitionNode` if a `with` clause was present</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># HANDLING the syntax &#39;onlayer -&gt; n * SPACE&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="s1">&#39;onlayer&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        
        <span class="c1"># HANDLING the syntax &#39;layer&#39;: The user used either a renpy keyword (only &#39;master&#39; is accepted for this project) or his own custom named layer</span>
        <span class="n">layer_ast</span> <span class="o">=</span> <span class="n">LayerNode</span><span class="p">(</span><span class="n">layer_name</span><span class="o">=</span><span class="s1">&#39;master&#39;</span><span class="p">)</span>
        <span class="n">token_value</span> <span class="o">=</span> <span class="n">__GET__VALUE__TOKEN__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">token_value</span> <span class="o">!=</span> <span class="s1">&#39;master&#39;</span><span class="p">:</span> 
            <span class="n">layer_ast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_user</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;BUILTIN&#39;</span><span class="p">,</span> <span class="n">token_value</span><span class="p">)</span>
        
        <span class="c1"># HANDLING the syntax &#39;n * SPACE&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        
        <span class="c1"># UPDATING args</span>
        <span class="n">args</span><span class="p">[</span><span class="s1">&#39;layer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer_ast</span>

        <span class="c1"># HANDLING next token:</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;COMMENT&#39;</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">args</span>
        
        <span class="c1"># HANDLING &#39;at&#39;, &#39;onlayer&#39; or &#39;with&#39; using a dispatch table:</span>
        <span class="n">syntax_handler</span> <span class="o">=</span> <span class="p">{</span> <span class="c1"># We use a dispatch_table instead of if/else if imbriqus</span>
            <span class="s2">&quot;with&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_with</span>
        <span class="p">}</span>

        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dispatch</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">syntax_handler</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">args</span></div>

    
<div class="viewcode-block" id="DispatchParser.parse_transform">
<a class="viewcode-back" href="../Parser.html#Parser.DispatchParser.parse_transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Parses a `transform` statement that specifies a positioning or transformation for a scene element.  </span>
<span class="sd">        The syntax handled includes:</span>

<span class="sd">            scene &lt;image_expression&gt; at &lt;transform&gt;</span>
<span class="sd">            scene &lt;image_expression&gt; at &lt;transform&gt; with &lt;transition&gt;</span>
<span class="sd">            scene &lt;image_expression&gt; at &lt;transform&gt; onlayer &lt;layer&gt; [with &lt;transition&gt;]</span>

<span class="sd">        Where `&lt;transform&gt;` can be one of the following BUILTIN values:</span>
<span class="sd">            &#39;center&#39;, &#39;left&#39;, &#39;right&#39;, &#39;top&#39;, &#39;bottom&#39;, &#39;offscreenleft&#39;, &#39;offscreenright&#39;,</span>
<span class="sd">            &#39;topleft&#39;, &#39;topright&#39;, &#39;bottomleft&#39;, &#39;bottomright&#39;</span>

<span class="sd">        The method also optionally handles `with` or `onlayer` clauses using a dispatch table.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        args: dict</span>
<span class="sd">            Dictionary of arguments to update. The parsed transform is stored under the key `&#39;transform&#39;`.  </span>
<span class="sd">            Additional keys such as `&#39;layer&#39;` or `&#39;transition&#39;` may be added if corresponding clauses are present.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            The updated `args` dictionary containing:</span>
<span class="sd">            - `&#39;transform&#39;`: the parsed `TransformNode`</span>
<span class="sd">            - `&#39;layer&#39;` (optional): if an `onlayer` clause was present</span>
<span class="sd">            - `&#39;transition&#39;` (optional): if a `with` clause was present</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># HANDLING the syntax &#39;at -&gt; n * SPACE&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="s1">&#39;at&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>

        <span class="c1"># HANDLING the syntax &#39;transform -&gt; n * SPACE&#39;</span>
        <span class="n">acceptable_transform</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">,</span> <span class="s1">&#39;offscreenleft&#39;</span><span class="p">,</span> <span class="s1">&#39;offscreenright&#39;</span><span class="p">,</span> <span class="s1">&#39;topleft&#39;</span><span class="p">,</span> <span class="s1">&#39;topright&#39;</span><span class="p">,</span> <span class="s1">&#39;bottomleft&#39;</span><span class="p">,</span> <span class="s1">&#39;bottomright&#39;</span><span class="p">]</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">token_value</span> <span class="o">=</span> <span class="n">__GET__VALUE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">token_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">acceptable_transform</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Scene syntax error. Expected an argument among: </span><span class="si">{</span><span class="n">acceptable_transform</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># Note: si __GET__VALUE__TOKEN__ peut raise Error, on perd de l&#39;information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;BUILTIN&#39;</span><span class="p">,</span> <span class="n">token_value</span><span class="p">)</span>
        <span class="n">transform_ast</span> <span class="o">=</span> <span class="n">TransformNode</span><span class="p">(</span><span class="n">transform_name</span> <span class="o">=</span> <span class="n">token_value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>

        <span class="c1"># UPDATING args</span>
        <span class="n">args</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transform_ast</span>

        <span class="c1"># HANDLING whether the statement is done or not:</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;COMMENT&#39;</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span> 
            <span class="k">return</span> <span class="n">args</span>
        
        <span class="c1"># HANDLING &#39;with&#39;, or &#39;onlayer&#39; using a dispatch table:</span>
        <span class="n">syntax_handler</span> <span class="o">=</span> <span class="p">{</span> <span class="c1"># We use a dispatch_table instead of if/else if imbriqus</span>
            <span class="s2">&quot;with&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_with</span><span class="p">,</span>
            <span class="s2">&quot;onlayer&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_onlayer</span>
        <span class="p">}</span>

        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dispatch</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">syntax_handler</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">args</span></div>

    
<div class="viewcode-block" id="DispatchParser.parse_image_expression">
<a class="viewcode-back" href="../Parser.html#Parser.DispatchParser.parse_image_expression">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_image_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Parses an image expression in a scene statement.  </span>
<span class="sd">        The possible syntax is:</span>

<span class="sd">            scene &lt;image_expression&gt; [at &lt;transform&gt;] [onlayer &lt;layer&gt;] [with &lt;transition&gt;]</span>

<span class="sd">        Where:</span>
<span class="sd">        - `&lt;image_expression&gt;` is one or more USER tokens representing the image or variable</span>
<span class="sd">        - `&lt;transform&gt;` is a transform (parsed via `parse_transform`)</span>
<span class="sd">        - `&lt;layer&gt;` is a layer (parsed via `parse_onlayer`)</span>
<span class="sd">        - `&lt;transition&gt;` is a transition (parsed via `parse_with`)</span>

<span class="sd">        The method handles all relevant dispatch keywords: `at`, `onlayer`, `with`.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        args: dict</span>
<span class="sd">            Dictionary of arguments to update. Parsed components are stored under:</span>
<span class="sd">            - `&#39;image_expression&#39;`: list of parsed USER tokens</span>
<span class="sd">            - `&#39;transform&#39;`, `&#39;layer&#39;`, `&#39;transition&#39;`: optional, depending on clauses present</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            The updated `args` dictionary containing the parsed image expression and any optional clauses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">token_type</span><span class="p">,</span> <span class="n">token_value</span> <span class="o">=</span> <span class="n">__BREAK__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> 

        <span class="c1"># HANDLING syntax &#39;image_expression -&gt; n * SPACE&#39;</span>
        <span class="n">stopping_values</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;at&#39;</span><span class="p">,</span> <span class="s1">&#39;onlayer&#39;</span><span class="p">,</span> <span class="s1">&#39;with&#39;</span><span class="p">]</span>
        <span class="n">img_expression</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">token</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="ow">and</span> <span class="n">token_type</span> <span class="o">!=</span> <span class="s1">&#39;COMMENT&#39;</span> <span class="ow">and</span> <span class="n">token_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stopping_values</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">token_type</span> <span class="o">==</span> <span class="s1">&#39;USER&#39;</span><span class="p">:</span>
                <span class="n">img_expression</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_user</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">token_type</span> <span class="o">==</span> <span class="s1">&#39;SPACE&#39;</span><span class="p">:</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;SPACE&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Scene syntax error. Expected either USER token or SPACE token and got </span><span class="si">{</span><span class="n">token</span><span class="si">}</span><span class="s1"> instead&#39;</span><span class="p">)</span>
            <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># print(&quot;token = &quot;, token)</span>
            <span class="n">token_type</span><span class="p">,</span> <span class="n">token_value</span> <span class="o">=</span> <span class="n">__BREAK__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        
        <span class="c1"># UPDATING args</span>
        <span class="n">args</span><span class="p">[</span><span class="s1">&#39;image_expression&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">img_expression</span>

        <span class="c1"># HANDLING next token, if it&#39;s EOF or NEWLINE we return the current args for parent function (parse_scene):</span>
        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;COMMENT&#39;</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">args</span>
        
        <span class="c1"># HANDLING &#39;at&#39;, &#39;onlayer&#39; or &#39;with&#39; using a dispatch table:</span>
        <span class="n">syntax_handler</span> <span class="o">=</span> <span class="p">{</span> <span class="c1"># We use a dispatch_table instead of if/else if imbriqus</span>
            <span class="s2">&quot;at&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_transform</span><span class="p">,</span>
            <span class="s2">&quot;onlayer&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_onlayer</span><span class="p">,</span>
            <span class="s2">&quot;with&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_with</span>
        <span class="p">}</span>

        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dispatch</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">syntax_handler</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">args</span></div>
</div>

    



<div class="viewcode-block" id="SceneParser">
<a class="viewcode-back" href="../Parser.html#Parser.SceneParser">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SceneParser</span><span class="p">(</span><span class="n">DispatchParser</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specific class to handle scene keyword with dispatch table (parent parser)&quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_tokens</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">list_tokens</span><span class="p">)</span>
    
<div class="viewcode-block" id="SceneParser.parse_scene">
<a class="viewcode-back" href="../Parser.html#Parser.SceneParser.parse_scene">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_scene</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># ok but develop the children handler</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Parses a `scene` statement, handling multiple syntactic variations through recursive dispatch tables.  </span>
<span class="sd">        The possible syntax is:</span>

<span class="sd">            scene [&lt;image_expression&gt;] [at &lt;transform&gt;] [onlayer &lt;layer&gt;] [with &lt;transition&gt;]</span>

<span class="sd">        Where:</span>
<span class="sd">        - `&lt;image_expression&gt;`: one or more USER tokens representing the image or variable</span>
<span class="sd">        - `&lt;transform&gt;`: a transform (parsed via `parse_transform`)</span>
<span class="sd">        - `&lt;layer&gt;`: a layer (parsed via `parse_onlayer`)</span>
<span class="sd">        - `&lt;transition&gt;`: a transition (parsed via `parse_with`)</span>

<span class="sd">        This method handles the initial cases (scene alone or followed by `image_expression`, `with`, or `onlayer`) and delegates more complex clauses to appropriate parser methods via dispatch tables.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SceneNode</span>
<span class="sd">            AST node representing the parsed scene, containing optional fields:</span>
<span class="sd">            - `image_expression`: list of USER tokens or None</span>
<span class="sd">            - `transform`: parsed `TransformNode` or None</span>
<span class="sd">            - `layer`: parsed `LayerNode` or None</span>
<span class="sd">            - `transition`: parsed `TransitionNode` or None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># mot-cl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="s1">&#39;scene&#39;</span><span class="p">)</span>
        <span class="c1"># self.eat(&#39;SPACE&#39;) # Minimum one space? Wrong, we could also have a NEWLINE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span> 

        <span class="c1"># HANDLING the situation where &#39;scene&#39; is not followed by any other argument accepted by the renpy syntax </span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;COMMENT&#39;</span><span class="p">:</span> 
            <span class="k">return</span> <span class="n">SceneNode</span><span class="p">()</span> <span class="c1"># syntax corresponds to &#39;scene&#39; only</span>
        
        <span class="c1"># We will build the arguments of SceneNode with all the dispatch handler. We start from here:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;image_expression&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> 
            <span class="s1">&#39;transform&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> 
            <span class="s1">&#39;layer&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> 
            <span class="s1">&#39;transition&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>

        <span class="c1"># Use a dispatch table like a real compiler:</span>
        <span class="n">syntax_handler</span> <span class="o">=</span> <span class="p">{</span> <span class="c1"># We use a dispatch_table instead of if/else if imbriqus</span>
            <span class="s2">&quot;USER&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_image_expression</span><span class="p">,</span>  
            <span class="s2">&quot;at&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_transform</span><span class="p">,</span>
            <span class="s2">&quot;onlayer&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_onlayer</span><span class="p">,</span>
            <span class="s2">&quot;with&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_with</span>
        <span class="p">}</span>

        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dispatch</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">syntax_handler</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">SceneNode</span><span class="p">(</span>
            <span class="n">image_expression</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;image_expression&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;transform&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">layer</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;layer&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">transition</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;transition&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> 
        <span class="p">)</span></div>
</div>


<div class="viewcode-block" id="ShowParser">
<a class="viewcode-back" href="../Parser.html#Parser.ShowParser">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ShowParser</span><span class="p">(</span><span class="n">DispatchParser</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specific class to handler show keyword with dispatch tables (parent handler)&quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_tokens</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">list_tokens</span><span class="p">)</span>
    
<div class="viewcode-block" id="ShowParser.parse_show">
<a class="viewcode-back" href="../Parser.html#Parser.ShowParser.parse_show">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_show</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># ok but develop the children handler</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Parses a `show` statement, handling multiple syntactic variations through recursive dispatch tables.  </span>
<span class="sd">        The possible syntax is:</span>

<span class="sd">            show [&lt;image_expression&gt;] [at &lt;transform&gt;] [onlayer &lt;layer&gt;] [with &lt;transition&gt;]</span>

<span class="sd">        Where:</span>
<span class="sd">        - `&lt;image_expression&gt;`: one or more USER tokens representing the image or variable</span>
<span class="sd">        - `&lt;transform&gt;`: a transform (parsed via `parse_transform`)</span>
<span class="sd">        - `&lt;layer&gt;`: a layer (parsed via `parse_onlayer`)</span>
<span class="sd">        - `&lt;transition&gt;`: a transition (parsed via `parse_with`)</span>

<span class="sd">        This method handles the initial cases (`show` alone or followed by `image_expression`, `with`, or `onlayer`) and delegates more complex clauses to the appropriate parser methods via dispatch tables.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ShowNode</span>
<span class="sd">            AST node representing the parsed show statement, containing optional fields:</span>
<span class="sd">            - `image_expression`: list of USER tokens or None</span>
<span class="sd">            - `transform`: parsed `TransformNode` or None</span>
<span class="sd">            - `layer`: parsed `LayerNode` or None</span>
<span class="sd">            - `transition`: parsed `TransitionNode` or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># mot-cl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="s1">&#39;show&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span> 

        <span class="c1"># HANDLING the situation where &#39;scene&#39; is not followed by any other argument accepted by the renpy syntax </span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;COMMENT&#39;</span><span class="p">:</span> 
            <span class="k">return</span> <span class="n">ShowNode</span><span class="p">()</span> <span class="c1"># syntax corresponds to &#39;show&#39; only</span>
        
        <span class="c1"># We will build the arguments of SceneNode with all the dispatch handler. We start from here:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;image_expression&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> 
            <span class="s1">&#39;transform&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> 
            <span class="s1">&#39;layer&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> 
            <span class="s1">&#39;transition&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>

        <span class="c1"># Use a dispatch table like a real compiler:</span>
        <span class="n">syntax_handler</span> <span class="o">=</span> <span class="p">{</span> <span class="c1"># We use a dispatch_table instead of if/else if imbriqus</span>
            <span class="s2">&quot;USER&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_image_expression</span><span class="p">,</span>  
            <span class="s2">&quot;at&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_transform</span><span class="p">,</span>
            <span class="s2">&quot;onlayer&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_onlayer</span><span class="p">,</span>
            <span class="s2">&quot;with&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_with</span>
        <span class="p">}</span>

        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dispatch</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">syntax_handler</span><span class="p">)</span>

        <span class="c1"># print(&quot;args = &quot;, args)</span>
        <span class="c1"># remove self.eof_line() from all dispatcher and call it here just once ?</span>
        <span class="k">return</span> <span class="n">ShowNode</span><span class="p">(</span>
            <span class="n">image_expression</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;image_expression&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;transform&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">layer</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;layer&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">transition</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;transition&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> 
        <span class="p">)</span></div>
</div>


<div class="viewcode-block" id="HideParser">
<a class="viewcode-back" href="../Parser.html#Parser.HideParser">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HideParser</span><span class="p">(</span><span class="n">DispatchParser</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specific class to handler hide keyword with dispatch tables (parent handler)&quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_tokens</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">list_tokens</span><span class="p">)</span>

<div class="viewcode-block" id="HideParser.parse_hide">
<a class="viewcode-back" href="../Parser.html#Parser.HideParser.parse_hide">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_hide</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Parses a `hide` statement, handling multiple syntactic variations through recursive dispatch tables.  </span>
<span class="sd">        The possible syntax is:</span>

<span class="sd">            hide [&lt;image_expression&gt;] [onlayer &lt;layer&gt;] [with &lt;transition&gt;]</span>

<span class="sd">        Where:</span>
<span class="sd">        - `&lt;image_expression&gt;`: one or more USER tokens representing the image or variable</span>
<span class="sd">        - `&lt;layer&gt;`: a layer (parsed via `parse_onlayer`)</span>
<span class="sd">        - `&lt;transition&gt;`: a transition (parsed via `parse_with`)</span>

<span class="sd">        This method handles the initial cases (`hide` alone or followed by `image_expression`, `with`, or `onlayer`) and delegates more complex clauses to the appropriate parser methods via dispatch tables.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        HideNode</span>
<span class="sd">            AST node representing the parsed hide statement, containing optional fields:</span>
<span class="sd">            - `image_expression`: list of USER tokens or None</span>
<span class="sd">            - `layer`: parsed `LayerNode` or None</span>
<span class="sd">            - `transition`: parsed `TransitionNode` or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># mot-cl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="s1">&#39;hide&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span> 

        <span class="c1"># HANDLING the situation where &#39;scene&#39; is not followed by any other argument accepted by the renpy syntax </span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;COMMENT&#39;</span><span class="p">:</span> 
            <span class="k">return</span> <span class="n">HideNode</span><span class="p">()</span> <span class="c1"># syntax corresponds to &#39;show&#39; only</span>
        
        <span class="c1"># We will build the arguments of SceneNode with all the dispatch handler. We start from here:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;image_expression&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> 
            <span class="s1">&#39;layer&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> 
            <span class="s1">&#39;transition&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>

        <span class="c1"># Use a dispatch table like a real compiler:</span>
        <span class="n">syntax_handler</span> <span class="o">=</span> <span class="p">{</span> <span class="c1"># We use a dispatch_table instead of if/else if imbriqus</span>
            <span class="s2">&quot;USER&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_image_expression</span><span class="p">,</span>  
            <span class="s2">&quot;onlayer&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_onlayer</span><span class="p">,</span>
            <span class="s2">&quot;with&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_with</span>
        <span class="p">}</span>

        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dispatch</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">syntax_handler</span><span class="p">)</span>

        <span class="c1"># print(&quot;args = &quot;, args)</span>
        <span class="c1"># remove self.eof_line() from all dispatcher and call it here just once ?</span>
        <span class="k">return</span> <span class="n">HideNode</span><span class="p">(</span>
            <span class="n">image_expression</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;image_expression&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">layer</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;layer&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">transition</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;transition&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> 
        <span class="p">)</span></div>
</div>




<div class="viewcode-block" id="LabelParser">
<a class="viewcode-back" href="../Parser.html#Parser.LabelParser">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LabelParser</span><span class="p">(</span><span class="n">SceneParser</span><span class="p">,</span> <span class="n">ShowParser</span><span class="p">,</span> <span class="n">HideParser</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Specific class to handler label keyword with dispatch tables (parent handler)&quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_tokens</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">list_tokens</span><span class="p">)</span>

<div class="viewcode-block" id="LabelParser.parse_dialogue">
<a class="viewcode-back" href="../Parser.html#Parser.LabelParser.parse_dialogue">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_dialogue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># If we read a USER token inside label body: we expect to read a dialogue.</span>
        <span class="c1"># dialogue is something like e &quot;Hello, I am Eileen and I am talking&quot; where &#39;e&#39; was declared with &#39;define&#39; and &#39;Character&#39; statements</span>
        <span class="c1"># We can also have Character(&#39;Eileen&#39;) &quot;Hello I am eileen&quot; even if it&#39;s less common</span>
        <span class="n">token_type</span><span class="p">,</span> <span class="n">token_value</span> <span class="o">=</span>  <span class="n">__BREAK__TOKEN__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

        <span class="n">ast_speaker</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">token_type</span> <span class="o">==</span> <span class="s1">&#39;FUNCTION&#39;</span> <span class="ow">and</span> <span class="s1">&#39;Character(&#39;</span> <span class="ow">in</span> <span class="n">token_value</span><span class="p">:</span>
            <span class="n">ast_speaker</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_function_call</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ast_speaker</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_user</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        <span class="n">ast_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_string</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">DialogueNode</span><span class="p">(</span><span class="n">speaker</span><span class="o">=</span><span class="n">ast_speaker</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">ast_string</span><span class="p">)</span></div>



<div class="viewcode-block" id="LabelParser.check_body_token">
<a class="viewcode-back" href="../Parser.html#Parser.LabelParser.check_body_token">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_body_token</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Checks the next token at the beginning of a line inside a label body and dispatches to the appropriate parser method.  </span>
<span class="sd">        Acceptable tokens include: `scene`, `show`, `hide`, `play`, `stop`, `with`, `jump`, `return`, `STRING`, `COMMENT`, `USER`.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ASTNode</span>
<span class="sd">            The AST node returned by the corresponding parser method for the current token.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">syntax_handler</span> <span class="o">=</span> <span class="p">{</span> 
            <span class="s1">&#39;scene&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_scene</span><span class="p">,</span>
            <span class="s1">&#39;show&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_show</span><span class="p">,</span>
            <span class="s1">&#39;hide&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_hide</span><span class="p">,</span>
            <span class="s1">&#39;play&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_play</span><span class="p">,</span>
            <span class="s1">&#39;with&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_with</span><span class="p">,</span>
            <span class="s1">&#39;stop&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_stop</span><span class="p">,</span>
            <span class="s1">&#39;STRING&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_string</span><span class="p">,</span>
            <span class="s1">&#39;COMMENT&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_comment</span><span class="p">,</span>
            <span class="s1">&#39;return&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_return</span><span class="p">,</span>
            <span class="s1">&#39;jump&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_jump</span><span class="p">,</span>
            <span class="s1">&#39;USER&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_dialogue</span>
            <span class="c1"># &#39;DOLLARS&#39;: self.parse_dollars, # Not implemented</span>
        <span class="p">}</span>

        <span class="n">parse_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parser</span><span class="p">(</span><span class="n">syntax_handler</span><span class="p">)</span>
        <span class="n">ast_object</span> <span class="o">=</span> <span class="n">parse_method</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">ast_object</span></div>


<div class="viewcode-block" id="LabelParser.check_end_label">
<a class="viewcode-back" href="../Parser.html#Parser.LabelParser.check_end_label">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_end_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">INDENTATION</span><span class="p">):</span>
        <span class="c1"># Verify all the possible condition telling us the label has ended whenever we read a NEWLINE during parse_label</span>

        <span class="c1"># Tokens that can appear at the top level, outside any label are listed inside top_level_starter_token_values. </span>
        <span class="c1"># These tokens represent the first element of a top-level statement:</span>
        <span class="c1"># - &#39;define&#39;, &#39;image&#39;, &#39;color&#39;  global definitions</span>
        <span class="c1"># - &#39;label&#39;, &#39;master&#39;          label or layer definitions</span>
        <span class="c1"># - &#39;$&#39;                        inline Python statements</span>
        <span class="c1"># - &#39;#&#39;                        comments</span>
        <span class="c1"># - &#39;\n&#39;                       blank lines / statement separators</span>

        <span class="c1"># Current token is NEWLINE token</span>
        <span class="n">indent_cpt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tk_type</span> <span class="o">=</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">token</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="ow">and</span> <span class="n">tk_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;NEWLINE&#39;</span><span class="p">,</span> <span class="s1">&#39;SPACE&#39;</span><span class="p">]:</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span><span class="p">:</span> <span class="c1"># We may have multiple NEWLINE tokens</span>
                <span class="n">indent_cpt</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eat_optional</span><span class="p">(</span><span class="s1">&#39;NEWLINE&#39;</span><span class="p">)</span>

            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;SPACE&#39;</span><span class="p">:</span> <span class="c1"># We may have more space but they are optional</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eat_optional</span><span class="p">(</span><span class="s1">&#39;SPACE&#39;</span><span class="p">)</span>
                <span class="n">indent_cpt</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;COMMENT&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parse_comment</span><span class="p">()</span>

            <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tk_type</span> <span class="o">=</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">indent_cpt</span> <span class="o">==</span> <span class="n">INDENTATION</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span><span class="p">:</span> <span class="c1"># No need to check indentation for a comment</span>
                <span class="k">return</span> <span class="kc">True</span> 
            <span class="k">elif</span> <span class="n">indent_cpt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># We check the first non-SPACE and non-NEWLINE token at the beginning of a line</span>
                <span class="k">if</span> <span class="n">__GET__VALUE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="ow">in</span> <span class="n">TOPLEVEL_TOKENS_VALUES</span> <span class="ow">or</span> <span class="n">__GET__TYPE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="ow">in</span> <span class="n">TOPLEVEL_TOKENS_VALUES</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># We only accept certain tokens values/types as top level token as defined by TOPLEVEL_TOKENS_VALUES</span>
                    <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="s1">&#39;Syntax error for label. Unexpected token declared outside all labels&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># The indentation does not match what we expected.</span>
                <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="s1">&#39;Syntax error for label. Each line in label body must have the same indent&#39;</span><span class="p">)</span></div>

       
<div class="viewcode-block" id="LabelParser.parse_label">
<a class="viewcode-back" href="../Parser.html#Parser.LabelParser.parse_label">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><span class="c1"># We only eat NEWLINE HERE !!!!!</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description</span>
<span class="sd">        -----------</span>
<span class="sd">        Parses a label definition and its body.  </span>
<span class="sd">        The syntax handled is:</span>

<span class="sd">            label &lt;label_name&gt;:</span>
<span class="sd">                &lt;body_statements&gt;</span>
<span class="sd">                return|jump</span>

<span class="sd">        Where `&lt;body_statements&gt;` can include any valid tokens parsed by `check_body_token` (scene, show, hide, play, etc.).  </span>
<span class="sd">        The method enforces consistent indentation for all lines in the label body.  </span>
<span class="sd">        The label must end with a `return` or `jump` statement.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        LabelNode</span>
<span class="sd">            AST node representing the parsed label, containing:</span>
<span class="sd">            - `label`: the name of the label</span>
<span class="sd">            - `body`: a list of AST nodes representing the statements inside the label</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span> 

        <span class="c1"># HANDLING whether it&#39;s the starting point of the game &#39;label start&#39; or not</span>
        <span class="n">token_value</span> <span class="o">=</span> <span class="n">__GET__VALUE__TOKEN__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">token_value</span> <span class="o">!=</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>  <span class="c1"># It must be a USER token</span>
            <span class="n">label_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_user</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;KEYWORD&#39;</span><span class="p">,</span> <span class="n">token_value</span><span class="p">)</span>
            <span class="n">label_name</span> <span class="o">=</span> <span class="n">KeywordNode</span><span class="p">(</span><span class="n">token_value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="s1">&#39;COLON&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_spaces</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eat_optional</span><span class="p">(</span><span class="s1">&#39;NEWLINE&#39;</span><span class="p">)</span>

        <span class="c1"># HANDLING body of the label</span>
        <span class="c1"># Body begins: (we can have pretty much anything we want that is inside TOKENS or a user variable)</span>
        <span class="c1"># We count the amount of SPACE before next command: this gives us the indentation that MUST be respected after a NEWLINE token</span>
        <span class="n">IDENT_NB</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># We request that the indentation is at least one space</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;SPACE&#39;</span><span class="p">:</span> <span class="c1"># We may have more space but they are optional</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eat_optional</span><span class="p">(</span><span class="s1">&#39;SPACE&#39;</span><span class="p">)</span>
            <span class="n">IDENT_NB</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">if</span> <span class="n">IDENT_NB</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="s1">&#39;Syntax error label. Identation inside label body must be at least one SPACE.&#39;</span><span class="p">)</span>
        <span class="n">body_ast</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tk_type</span><span class="p">,</span> <span class="n">tk_val</span> <span class="o">=</span> <span class="n">__BREAK__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">token</span><span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span> <span class="ow">and</span> <span class="n">tk_val</span> <span class="o">!=</span> <span class="s1">&#39;label&#39;</span> <span class="ow">and</span> <span class="n">tk_val</span> <span class="o">!=</span> <span class="s1">&#39;return&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tk_type</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_end_label</span><span class="p">(</span><span class="n">IDENT_NB</span><span class="p">):</span> <span class="c1"># We check if the label is ending</span>
                    <span class="k">return</span> <span class="n">LabelNode</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label_name</span><span class="p">,</span> <span class="n">body</span><span class="o">=</span><span class="n">body_ast</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_body_token</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">ast</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">body_ast</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
            <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tk_type</span><span class="p">,</span> <span class="n">tk_val</span> <span class="o">=</span> <span class="n">__BREAK__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        
        <span class="c1"># if token == self.EOF:</span>
        <span class="c1">#    raise DetailedError(&#39;Syntax error for label. expected return or jump.&#39;)</span>
        
        <span class="c1"># HANDLING either return of jump (these two are optional)</span>
        <span class="k">if</span> <span class="n">__GET__VALUE__TOKEN__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;return&#39;</span><span class="p">,</span> <span class="s1">&#39;jump&#39;</span><span class="p">]:</span>
            <span class="n">body_ast</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">check_body_token</span><span class="p">())</span> <span class="c1"># obtain return or jump</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eof_line</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">LabelNode</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label_name</span><span class="p">,</span> <span class="n">body</span><span class="o">=</span><span class="n">body_ast</span><span class="p">)</span></div>
</div>

    


<div class="viewcode-block" id="MasterParser">
<a class="viewcode-back" href="../Parser.html#Parser.MasterParser">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MasterParser</span><span class="p">(</span><span class="n">LabelParser</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class that create the final AST tree object for the game</span>
<span class="sd">    </span>
<span class="sd">    Tips:</span>
<span class="sd">    A renpy file in this project is considered to be structured by labels and top-level lines.</span>
<span class="sd">    We call Top-level lines statements written outside of any label such as `define`, `image`, </span>
<span class="sd">    `play`.</span>
<span class="sd">    # They must appear before any label that uses them. Lines between labels</span>
<span class="sd">    # are only available to labels defined after them. Lines after all labels</span>
<span class="sd">    # are valid but unused if no label references them.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_tokens</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">list_tokens</span><span class="p">)</span>

<div class="viewcode-block" id="MasterParser.parse_toplevel_statement">
<a class="viewcode-back" href="../Parser.html#Parser.MasterParser.parse_toplevel_statement">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_toplevel_statement</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">syntax_handler</span> <span class="o">=</span> <span class="p">{</span> <span class="c1"># USER token not allowed (must be preceded by DOLLAR token)</span>
            <span class="s1">&#39;define&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_define</span><span class="p">,</span>
            <span class="s1">&#39;image&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_image</span><span class="p">,</span>
            <span class="s1">&#39;scene&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_scene</span><span class="p">,</span>
            <span class="s1">&#39;show&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_show</span><span class="p">,</span>
            <span class="s1">&#39;hide&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_hide</span><span class="p">,</span>
            <span class="s1">&#39;play&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_play</span><span class="p">,</span>
            <span class="s1">&#39;stop&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_stop</span><span class="p">,</span>
            <span class="s1">&#39;COMMENT&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_comment</span><span class="p">,</span>
            <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_label</span>
            <span class="c1"># &#39;DOLLARS&#39;: self.parse_dollars, # Not implemented</span>
        <span class="p">}</span>

        <span class="n">parse_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parser</span><span class="p">(</span><span class="n">syntax_handler</span><span class="p">)</span>
        <span class="n">ast_object</span> <span class="o">=</span> <span class="n">parse_method</span><span class="p">()</span>


        <span class="k">return</span> <span class="n">ast_object</span></div>


<div class="viewcode-block" id="MasterParser.parse_renpy_file">
<a class="viewcode-back" href="../Parser.html#Parser.MasterParser.parse_renpy_file">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_renpy_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Structure of AST:</span>
<span class="sd">        List according to order you read renpy file.</span>
<span class="sd">        Linkage resolution not done here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ast_master</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Program starts with &#39;label start&#39; or we have an error (I impose this condition) -&gt; Normally the error is raised during runtime, actually it&#39;s the same for all the error raised in this document but i don&#39;t care cause these methods will be run during runtime in fact.</span>
        <span class="n">found_label_start</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_tokens</span><span class="p">:</span>
            <span class="n">token_value</span> <span class="o">=</span> <span class="n">__GET__VALUE__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">token_value</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
                <span class="n">found_label_start</span> <span class="o">=</span> <span class="kc">True</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">found_label_start</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DetailedError</span><span class="p">(</span><span class="s1">&#39;Syntax error. Renpy script must contain an entry-point: label start&#39;</span><span class="p">)</span>
        
        <span class="c1"># HANDLING the entire renpy file:</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">token_type</span><span class="p">,</span> <span class="n">token_value</span> <span class="o">=</span> <span class="n">__BREAK__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">while</span><span class="p">(</span><span class="n">token</span><span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EOF</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">token_type</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span> <span class="ow">or</span> <span class="n">token_type</span> <span class="o">==</span> <span class="s1">&#39;SPACE&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">token_type</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># HANDLE all other scenarios</span>
                <span class="n">ast_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_toplevel_statement</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">ast_tree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ast_master</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ast_tree</span><span class="p">)</span>
            <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_peek</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">token_type</span><span class="p">,</span> <span class="n">token_value</span> <span class="o">=</span> <span class="n">__BREAK__TOKEN__</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">MasterNode</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="n">ast_master</span><span class="p">)</span></div>
</div>



<span class="c1"># Top-level lines are statements written outside of any label, they are defined</span>
<span class="c1"># inside TOPLEVEL_TOKENS_VALUES global variable.</span>
<span class="c1"># They must appear before any label that uses them. Lines between labels</span>
<span class="c1"># are only available to labels defined after them. Lines after all labels</span>
<span class="c1"># are valid but unused if no label references them.</span>



<span class="c1"># END OF MODULE PARSER</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, David J.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>